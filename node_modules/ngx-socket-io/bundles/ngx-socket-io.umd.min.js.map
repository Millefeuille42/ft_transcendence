{"version":3,"sources":["../../src/socket-io.service.ts","../../src/socket-io.module.ts"],"names":["WrappedSocket","config","this","subscribersCounter","eventObservables$","emptyConfig","url","options","undefined","ioFunc","io.default","io","ioSocket","prototype","of","namespace","on","eventName","callback","once","connect","disconnect","_close","apply","arguments","emit","_eventName","_args","_i","length","removeListener","_callback","removeAllListeners","fromEvent","_this","Observable","observer","listener","data","next","pipe","share","fromOneTimeEvent","Promise","resolve","SocketFactory","SOCKET_CONFIG_TOKEN","InjectionToken","SocketIoModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","NgModule","args"],"mappings":"u1BAgBE,SAAAA,EAAoBC,GAAAC,KAAAD,OAAAA,EARpBC,KAAAC,mBAA6C,GAC7CD,KAAAE,kBAAqD,GAErDF,KAAAG,YAA8B,CAC5BC,IAAK,GACLC,QAAS,SAIMC,IAAXP,IACFA,EAASC,KAAKG,aAEhB,IAAMC,EAAcL,EAAOK,IACrBC,EAAeN,EAAOM,QACtBE,EAAUC,EAAAA,QAAsBA,EAAAA,QAAqBC,EAC3DT,KAAKU,SAAWH,EAAOH,EAAKC,UAG9BP,EAAAa,UAAAC,GAAA,SAAGC,GACDb,KAAKU,SAASE,GAAGC,IAGnBf,EAAAa,UAAAG,GAAA,SAAGC,EAAmBC,GACpBhB,KAAKU,SAASI,GAAGC,EAAWC,IAG9BlB,EAAAa,UAAAM,KAAA,SAAKF,EAAmBC,GACtBhB,KAAKU,SAASO,KAAKF,EAAWC,IAGhClB,EAAAa,UAAAO,QAAA,WACE,OAAOlB,KAAKU,SAASQ,WAGvBpB,EAAAa,UAAAQ,WAAA,SAAWC,GACT,OAAOpB,KAAKU,SAASS,WAAWE,MAAMrB,KAAKU,SAAUY,YAGvDxB,EAAAa,UAAAY,KAAA,SAAKC,OAAoB,IAAAC,EAAA,GAAAC,EAAA,EAAAA,EAAAJ,UAAAK,OAAAD,IAAAD,EAAAC,EAAA,GAAAJ,UAAAI,GACvB,OAAO1B,KAAKU,SAASa,KAAKF,MAAMrB,KAAKU,SAAUY,YAGjDxB,EAAAa,UAAAiB,eAAA,SAAeJ,EAAoBK,GACjC,OAAO7B,KAAKU,SAASkB,eAAeP,MAAMrB,KAAKU,SAAUY,YAG3DxB,EAAAa,UAAAmB,mBAAA,SAAmBN,GACjB,OAAOxB,KAAKU,SAASoB,mBAAmBT,MAAMrB,KAAKU,SAAUY,YAG/DxB,EAAAa,UAAAoB,UAAA,SAAahB,GAAb,IAAAiB,EAAAhC,KAqBE,OApBKA,KAAKC,mBAAmBc,KAC3Bf,KAAKC,mBAAmBc,GAAa,GAEvCf,KAAKC,mBAAmBc,KAEnBf,KAAKE,kBAAkBa,KAC1Bf,KAAKE,kBAAkBa,GAAa,IAAIkB,EAAAA,YAAW,SAACC,GAClD,IAAMC,EAAW,SAACC,GAChBF,EAASG,KAAKD,IAGhB,OADAJ,EAAKtB,SAASI,GAAGC,EAAWoB,GACrB,WACLH,EAAK/B,mBAAmBc,KACmB,IAAvCiB,EAAK/B,mBAAmBc,KAC1BiB,EAAKtB,SAASkB,eAAeb,EAAWoB,UACjCH,EAAK9B,kBAAkBa,QAGjCuB,KAAKC,EAAAA,UAEHvC,KAAKE,kBAAkBa,IAGhCjB,EAAAa,UAAA6B,iBAAA,SAAoBzB,GAApB,IAAAiB,EAAAhC,KACE,OAAO,IAAIyC,SAAW,SAAAC,GAAW,OAAAV,EAAKf,KAAKF,EAAW2B,qBC9E1CC,EAAc5C,GAC5B,OAAO,IAAID,EAAcC,OAGd6C,EAAsB,IAAIC,EAAAA,eACrC,qCAIF,SAAAC,YACSA,EAAAC,QAAP,SAAehD,GACb,MAAO,CACLiD,SAAUF,EACVG,UAAW,CACT,CAAEC,QAASN,EAAqBO,SAAUpD,GAC1C,CACEmD,QAASpD,EACTsD,WAAYT,EACZU,KAAM,CAACT,gCAVhBU,EAAAA,SAAQC,KAAA,CAAC","sourcesContent":["import { Observable } from 'rxjs';\nimport { share } from 'rxjs/operators';\n\nimport * as io from 'socket.io-client';\n\nimport { SocketIoConfig } from './config/socket-io.config';\n\nexport class WrappedSocket {\n  subscribersCounter: Record<string, number> = {};\n  eventObservables$: Record<string, Observable<any>> = {};\n  ioSocket: any;\n  emptyConfig: SocketIoConfig = {\n    url: '',\n    options: {},\n  };\n\n  constructor(private config: SocketIoConfig) {\n    if (config === undefined) {\n      config = this.emptyConfig;\n    }\n    const url: string = config.url;\n    const options: any = config.options;\n    const ioFunc = (io as any).default ? (io as any).default : io;\n    this.ioSocket = ioFunc(url, options);\n  }\n\n  of(namespace: string) {\n    this.ioSocket.of(namespace);\n  }\n\n  on(eventName: string, callback: Function) {\n    this.ioSocket.on(eventName, callback);\n  }\n\n  once(eventName: string, callback: Function) {\n    this.ioSocket.once(eventName, callback);\n  }\n\n  connect() {\n    return this.ioSocket.connect();\n  }\n\n  disconnect(_close?: any) {\n    return this.ioSocket.disconnect.apply(this.ioSocket, arguments);\n  }\n\n  emit(_eventName: string, ..._args: any[]) {\n    return this.ioSocket.emit.apply(this.ioSocket, arguments);\n  }\n\n  removeListener(_eventName: string, _callback?: Function) {\n    return this.ioSocket.removeListener.apply(this.ioSocket, arguments);\n  }\n\n  removeAllListeners(_eventName?: string) {\n    return this.ioSocket.removeAllListeners.apply(this.ioSocket, arguments);\n  }\n\n  fromEvent<T>(eventName: string): Observable<T> {\n    if (!this.subscribersCounter[eventName]) {\n      this.subscribersCounter[eventName] = 0;\n    }\n    this.subscribersCounter[eventName]++;\n\n    if (!this.eventObservables$[eventName]) {\n      this.eventObservables$[eventName] = new Observable((observer: any) => {\n        const listener = (data: T) => {\n          observer.next(data);\n        };\n        this.ioSocket.on(eventName, listener);\n        return () => {\n          this.subscribersCounter[eventName]--;\n          if (this.subscribersCounter[eventName] === 0) {\n            this.ioSocket.removeListener(eventName, listener);\n            delete this.eventObservables$[eventName];\n          }\n        };\n      }).pipe(share());\n    }\n    return this.eventObservables$[eventName];\n  }\n\n  fromOneTimeEvent<T>(eventName: string): Promise<T> {\n    return new Promise<T>(resolve => this.once(eventName, resolve));\n  }\n}\n","import { NgModule, ModuleWithProviders, InjectionToken } from '@angular/core';\nimport { SocketIoConfig } from './config/socket-io.config';\nimport { WrappedSocket } from './socket-io.service';\n\n/** Socket factory */\nexport function SocketFactory(config: SocketIoConfig) {\n  return new WrappedSocket(config);\n}\n\nexport const SOCKET_CONFIG_TOKEN = new InjectionToken<SocketIoConfig>(\n  '__SOCKET_IO_CONFIG__'\n);\n\n@NgModule({})\nexport class SocketIoModule {\n  static forRoot(config: SocketIoConfig): ModuleWithProviders<SocketIoModule> {\n    return {\n      ngModule: SocketIoModule,\n      providers: [\n        { provide: SOCKET_CONFIG_TOKEN, useValue: config },\n        {\n          provide: WrappedSocket,\n          useFactory: SocketFactory,\n          deps: [SOCKET_CONFIG_TOKEN],\n        },\n      ],\n    };\n  }\n}\n"]}